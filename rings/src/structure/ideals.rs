use super::*;
use algebraeon_nzq::{Integer, Natural};
use algebraeon_sets::structure::common_structure;
use std::fmt::Debug;

pub trait IdealSignature: IntegralDomainSignature {
    type Ideal: Debug + Clone;
}
pub trait MetaIdealSignature: MetaIntegralDomain
where
    Self::Signature: IdealSignature,
{
}
impl<R: MetaRing> MetaIdealSignature for R where Self::Signature: IdealSignature<Set = R> {}

pub trait IdealArithmeticSignature: IdealSignature {
    // The zero ideal i.e. contains only 0
    fn zero_ideal(&self) -> Self::Ideal {
        self.principal_ideal(&self.zero())
    }
    
    // The unit ideal i.e. contains everything
    fn unit_ideal(&self) -> Self::Ideal {
        self.principal_ideal(&self.one())
    }
    
    /// The ideal generated by a list of elements
    fn generated_ideal(&self, elems: Vec<impl Into<Self::Set>>) -> Self::Ideal {
        self.ideal_sum(
            elems
                .into_iter()
                .map(|elem| self.principal_ideal(&elem.into()))
                .collect(),
        )
    }

    /// The principal ideal generated by a
    fn principal_ideal(&self, a: &Self::Set) -> Self::Ideal;

    /// Are the ideals equal?
    fn ideal_equal(&self, a: &Self::Ideal, b: &Self::Ideal) -> bool {
        self.ideal_contains(a, b) && self.ideal_contains(b, a)
    }

    /// Is the ideal the zero ideal
    fn ideal_is_zero(&self, a: &Self::Ideal) -> bool {
        self.ideal_equal(a, &self.zero_ideal())
    }

    /// Does a contain b i.e. does a divide b
    fn ideal_contains(&self, a: &Self::Ideal, b: &Self::Ideal) -> bool;

    /// Does a contain x
    fn ideal_contains_element(&self, a: &Self::Ideal, x: &Self::Set) -> bool {
        self.ideal_contains(a, &self.principal_ideal(x))
    }

    /// Intersection of ideals
    fn ideal_intersect(&self, a: &Self::Ideal, b: &Self::Ideal) -> Self::Ideal;

    /// Sum of two ideals
    fn ideal_add(&self, a: &Self::Ideal, b: &Self::Ideal) -> Self::Ideal;

    /// Sum of many ideals
    fn ideal_sum(&self, ideals: Vec<impl Into<Self::Ideal>>) -> Self::Ideal {
        let mut total = self.zero_ideal();
        for i in ideals {
            total = self.ideal_add(&total, &i.into());
        }
        total
    }

    /// Product of two ideals
    fn ideal_mul(&self, a: &Self::Ideal, b: &Self::Ideal) -> Self::Ideal;

    /// Sum of many ideals
    fn ideal_product(&self, ideals: Vec<impl Into<Self::Ideal>>) -> Self::Ideal {
        let mut total = self.unit_ideal();
        for i in ideals {
            total = self.ideal_mul(&total, &i.into());
        }
        total
    }

    /// ideal to a natural power
    fn ideal_nat_pow(&self, ideal: &Self::Ideal, n: &Natural) -> Self::Ideal {
        if *n == Natural::ZERO {
            self.unit_ideal()
        } else if *n == Natural::ONE {
            ideal.clone()
        } else {
            debug_assert!(*n >= Natural::TWO);
            let bits: Vec<_> = n.bits().collect();
            let mut pows = vec![ideal.clone()];
            while pows.len() < bits.len() {
                pows.push(self.ideal_mul(pows.last().unwrap(), pows.last().unwrap()));
            }
            let count = bits.len();
            debug_assert_eq!(count, pows.len());
            let mut ans = self.unit_ideal();
            for i in 0..count {
                if bits[i] {
                    ans = self.ideal_mul(&ans, &pows[i]);
                }
            }
            ans
        }
    }
}
pub trait MetaIdealArithmeticSignature: MetaIdealSignature
where
    Self::Signature: IdealArithmeticSignature,
{
    // The zero ideal i.e. contains only 0
    fn zero_ideal(&self) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().zero_ideal()
    }
    // The unit ideal i.e. contains everything
    fn unit_ideal(&self) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().unit_ideal()
    }
    /// The ideal generated by a list of elements
    fn generated_ideal(elems: Vec<impl Into<Self>>) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().generated_ideal(elems)
    }
    /// The principal ideal generated by a
    fn principal_ideal(&self) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().principal_ideal(self)
    }
    /// Are the ideals equal?
    fn ideal_equal(
        a: &<Self::Signature as IdealSignature>::Ideal,
        b: &<Self::Signature as IdealSignature>::Ideal,
    ) -> bool {
        Self::structure().ideal_equal(a, b)
    }
    /// Is the ideal the zero ideal
    fn ideal_is_zero(a: &<Self::Signature as IdealSignature>::Ideal) -> bool {
        Self::structure().ideal_is_zero(a)
    }
    /// Does a contain b i.e. does a divide b
    fn ideal_contains(
        a: &<Self::Signature as IdealSignature>::Ideal,
        b: &<Self::Signature as IdealSignature>::Ideal,
    ) -> bool {
        Self::structure().ideal_contains(a, b)
    }
    /// Intersection of ideals
    fn ideal_intersect(
        a: &<Self::Signature as IdealSignature>::Ideal,
        b: &<Self::Signature as IdealSignature>::Ideal,
    ) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().ideal_intersect(a, b)
    }
    // Sum of two ideals
    fn ideal_add(
        a: &<Self::Signature as IdealSignature>::Ideal,
        b: &<Self::Signature as IdealSignature>::Ideal,
    ) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().ideal_add(a, b)
    }
    // Sum of many ideals
    fn ideal_sum(
        ideals: Vec<impl Into<<Self::Signature as IdealSignature>::Ideal>>,
    ) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().ideal_sum(ideals)
    }
    // Product of two ideals
    fn ideal_mul(
        a: &<Self::Signature as IdealSignature>::Ideal,
        b: &<Self::Signature as IdealSignature>::Ideal,
    ) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().ideal_mul(a, b)
    }
    // Sum of many ideals
    fn ideal_product(
        ideals: Vec<impl Into<<Self::Signature as IdealSignature>::Ideal>>,
    ) -> <Self::Signature as IdealSignature>::Ideal {
        Self::structure().ideal_product(ideals)
    }
}
impl<R: MetaRing> MetaIdealArithmeticSignature for R where
    Self::Signature: IdealArithmeticSignature<Set = R>
{
}

pub trait PrincipalIdealDomainSignature: IdealSignature {
    fn ideal_generator(&self, ideal: &Self::Ideal) -> Self::Set;
}
pub trait MetaPrincipalIdealDomainSignature: MetaIdealSignature
where
    Self::Signature: PrincipalIdealDomainSignature,
{
    fn ideal_generator(ideal: &<Self::Signature as IdealSignature>::Ideal) -> Self {
        Self::structure().ideal_generator(ideal)
    }
}
impl<R: MetaRing> MetaPrincipalIdealDomainSignature for R where
    Self::Signature: PrincipalIdealDomainSignature<Set = R>
{
}

#[derive(Debug, Clone)]
pub struct DedekindDomainPrimeIdeal<RS: DedekindDomainSignature> {
    prime_ideal: RS::Ideal,
}

impl<RS: DedekindDomainSignature> DedekindDomainPrimeIdeal<RS> {
    pub fn from_ideal_unchecked(ideal: RS::Ideal) -> Self {
        Self { prime_ideal: ideal }
    }

    pub fn into_ideal(self) -> RS::Ideal {
        self.prime_ideal
    }

    pub fn ideal(&self) -> &RS::Ideal {
        &self.prime_ideal
    }
}

impl<RS: DedekindDomainSignature> FactoredSignature<DedekindDomainIdealFactorization<RS>> for RS {
    type PrimeObject = DedekindDomainPrimeIdeal<RS>;

    type Object = RS::Ideal;

    fn object_divides(&self, a: &Self::Object, b: &Self::Object) -> bool {
        self.ideal_contains(a, b)
    }

    fn object_is_prime(&self, _object: &Self::PrimeObject) -> bool {
        true
    }

    fn prime_to_object(&self, prime: Self::PrimeObject) -> Self::Object {
        prime.into_ideal()
    }

    fn object_product(&self, objects: Vec<&Self::Object>) -> Self::Object {
        self.ideal_product(objects.into_iter().cloned().collect())
    }
}

#[derive(Debug, Clone)]
pub struct DedekindDomainIdealFactorization<RS: DedekindDomainSignature> {
    ring: RS,
    // The prime ideals should be distinct
    // All powers should be non-zero
    factors: Vec<(DedekindDomainPrimeIdeal<RS>, Natural)>,
}

impl<RS: DedekindDomainSignature> Factored for DedekindDomainIdealFactorization<RS> {
    type Structure = RS;

    fn factored_structure<'a>(&'a self) -> impl 'a + std::borrow::Borrow<Self::Structure> {
        &self.ring
    }

    fn from_factor_powers_impl(
        structure: Self::Structure,
        factor_powers: Vec<(
            <Self::Structure as FactoredSignature<Self>>::PrimeObject,
            Natural,
        )>,
    ) -> Self {
        Self {
            ring: structure,
            factors: factor_powers,
        }
    }

    fn factor_powers(
        &self,
    ) -> Vec<(
        &<Self::Structure as FactoredSignature<Self>>::PrimeObject,
        &Natural,
    )> {
        self.factors.iter().map(|(p, k)| (p, k)).collect()
    }

    fn into_factor_powers(
        self,
    ) -> Vec<(
        <Self::Structure as FactoredSignature<Self>>::PrimeObject,
        Natural,
    )> {
        self.factors
    }

    fn expanded(&self) -> <Self::Structure as FactoredSignature<Self>>::Object {
        self.ring.ideal_product(
            self.factor_list()
                .into_iter()
                .map(|p| p.ideal().clone())
                .collect(),
        )
    }

    fn mul(mut a: Self, b: Self) -> Self {
        let ring = common_structure::<RS>(a.factored_structure(), b.factored_structure());
        for (q, l) in b.into_factor_powers() {
            'SEARCH_A: {
                for (p, k) in &mut a.factors {
                    if ring.object_equivalent(p.ideal(), q.ideal()) {
                        *k += l;
                        break 'SEARCH_A;
                    }
                }
                a.factors.push((q, l));
            }
        }
        a
    }
}

/// A ring in which all ideals uniquely factor as a product of powers of prime ideals
pub trait DedekindDomainSignature: IdealArithmeticSignature {
    /// Return the largest power of prime_ideal which divides ideal
    fn largest_prime_ideal_factor_power(
        &self,
        prime_ideal: &DedekindDomainPrimeIdeal<Self>,
        ideal: &Self::Ideal,
    ) -> Natural {
        debug_assert!(!self.ideal_equal(prime_ideal.ideal(), &self.unit_ideal()));
        let mut k = Natural::ZERO;
        let mut prime_ideal_to_the_k_plus_one = prime_ideal.ideal().clone();
        while self.ideal_contains(&prime_ideal_to_the_k_plus_one, ideal) {
            k += Natural::ONE;
            prime_ideal_to_the_k_plus_one =
                self.ideal_mul(&prime_ideal_to_the_k_plus_one, prime_ideal.ideal())
        }
        k
    }
}

pub trait FactorableIdealsSignature: DedekindDomainSignature {
    fn factor_ideal(&self, ideal: &Self::Ideal) -> Option<DedekindDomainIdealFactorization<Self>>;
    fn is_prime_ideal(&self, ideal: &Self::Ideal) -> bool {
        if let Some(f) = self.factor_ideal(ideal) {
            f.is_prime()
        } else {
            false
        }
    }
}
pub trait MetaDedekindDomainSignature: MetaIdealArithmeticSignature
where
    Self::Signature: FactorableIdealsSignature,
{
    fn factor_ideal(
        ideal: &<Self::Signature as IdealSignature>::Ideal,
    ) -> Option<DedekindDomainIdealFactorization<Self::Signature>> {
        Self::structure().factor_ideal(ideal)
    }
    fn is_prime_ideal(ideal: &<Self::Signature as IdealSignature>::Ideal) -> bool {
        Self::structure().is_prime_ideal(ideal)
    }
}
impl<R: MetaRing> MetaDedekindDomainSignature for R where
    Self::Signature: FactorableIdealsSignature<Set = R>
{
}

#[derive(Debug, Clone)]
pub struct DedekindDomainFractionalIdeal<RS: DedekindDomainSignature> {
    ring: RS,
    // The prime ideals should be distinct
    // All powers should be non-zero
    factors: Vec<(DedekindDomainPrimeIdeal<RS>, Integer)>,
}
