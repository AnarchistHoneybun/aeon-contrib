use super::*;
use algebraeon_nzq::Natural;
use algebraeon_sets::structure::*;
use std::{fmt::Debug, marker::PhantomData};

pub trait DedekindDomainSignature: IntegralDomainSignature {}

pub trait CannonicalIdealsSignature: RingSignature {
    type Ideals: IdealsSignature<Self>;
    fn ideals(&self) -> Self::Ideals;
}
pub trait MetaCannonicalIdealsSignature: MetaType
where
    Self::Signature: CannonicalIdealsSignature,
{
    fn ideals() -> <Self::Signature as CannonicalIdealsSignature>::Ideals {
        Self::structure().ideals()
    }
}
impl<R: MetaType> MetaCannonicalIdealsSignature for R where R::Signature: CannonicalIdealsSignature {}

pub trait IdealsSignature<Ring: RingSignature>: SetSignature {
    fn ring(&self) -> &Ring;
}
// pub trait MetaIdealSignature<Ring: RingSignature>: MetaType
// where
//     Self::Signature: IdealSignature<Ring>,
// {
// }
// impl<R: MetaType, Ring: RingSignature> MetaIdealSignature<Ring> for R where
//     Self::Signature: IdealSignature<Ring>
// {
// }

pub trait IdealsArithmeticSignature<Ring: RingSignature>: IdealsSignature<Ring> {
    // The zero ideal i.e. contains only 0
    fn zero_ideal(&self) -> Self::Set {
        self.principal_ideal(&self.ring().zero())
    }

    // The unit ideal i.e. contains everything
    fn unit_ideal(&self) -> Self::Set {
        self.principal_ideal(&self.ring().one())
    }

    /// The ideal generated by a list of elements
    fn generated_ideal(&self, elems: Vec<impl Into<Ring::Set>>) -> Self::Set {
        self.ideal_sum(
            elems
                .into_iter()
                .map(|elem| self.principal_ideal(&elem.into()))
                .collect(),
        )
    }

    /// The principal ideal generated by a
    fn principal_ideal(&self, a: &Ring::Set) -> Self::Set;

    /// Are the ideals equal?
    fn ideal_equal(&self, a: &Self::Set, b: &Self::Set) -> bool {
        self.ideal_contains(a, b) && self.ideal_contains(b, a)
    }

    /// Is the ideal the zero ideal
    fn ideal_is_zero(&self, a: &Self::Set) -> bool {
        self.ideal_equal(a, &self.zero_ideal())
    }

    /// Does a contain b i.e. does a divide b
    fn ideal_contains(&self, a: &Self::Set, b: &Self::Set) -> bool;

    /// Does a contain x
    fn ideal_contains_element(&self, a: &Self::Set, x: &Ring::Set) -> bool {
        self.ideal_contains(a, &self.principal_ideal(x))
    }

    /// Intersection of ideals
    fn ideal_intersect(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// Sum of two ideals
    fn ideal_add(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// Sum of many ideals
    fn ideal_sum(&self, ideals: Vec<impl Into<Self::Set>>) -> Self::Set {
        let mut total = self.zero_ideal();
        for i in ideals {
            total = self.ideal_add(&total, &i.into());
        }
        total
    }

    /// Product of two ideals
    fn ideal_mul(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// Sum of many ideals
    fn ideal_product(&self, ideals: Vec<impl Into<Self::Set>>) -> Self::Set {
        let mut total = self.unit_ideal();
        for i in ideals {
            total = self.ideal_mul(&total, &i.into());
        }
        total
    }

    /// ideal to a natural power
    fn ideal_nat_pow(&self, ideal: &Self::Set, n: &Natural) -> Self::Set {
        if *n == Natural::ZERO {
            self.unit_ideal()
        } else if *n == Natural::ONE {
            ideal.clone()
        } else {
            debug_assert!(*n >= Natural::TWO);
            let bits: Vec<_> = n.bits().collect();
            let mut pows = vec![ideal.clone()];
            while pows.len() < bits.len() {
                pows.push(self.ideal_mul(pows.last().unwrap(), pows.last().unwrap()));
            }
            let count = bits.len();
            debug_assert_eq!(count, pows.len());
            let mut ans = self.unit_ideal();
            for i in 0..count {
                if bits[i] {
                    ans = self.ideal_mul(&ans, &pows[i]);
                }
            }
            ans
        }
    }
}

pub trait PrincipalIdealsSignature<Ring: RingSignature>: IdealsSignature<Ring> {
    fn ideal_generator(&self, ideal: &Self::Set) -> Ring::Set;
}

/// A ring in which all ideals uniquely factor as a product of powers of prime ideals
pub trait DedekindDomainIdealsSignature<Ring: DedekindDomainSignature>:
    IdealsArithmeticSignature<Ring>
{
    /// Return the largest power of prime_ideal which divides ideal
    fn largest_prime_ideal_factor_power(
        &self,
        prime_ideal: &DedekindDomainPrimeIdeal<Ring, Self>,
        ideal: &Self::Set,
    ) -> Natural {
        debug_assert!(!self.ideal_equal(prime_ideal.ideal(), &self.unit_ideal()));
        let mut k = Natural::ZERO;
        let mut prime_ideal_to_the_k_plus_one = prime_ideal.ideal().clone();
        while self.ideal_contains(&prime_ideal_to_the_k_plus_one, ideal) {
            k += Natural::ONE;
            prime_ideal_to_the_k_plus_one =
                self.ideal_mul(&prime_ideal_to_the_k_plus_one, prime_ideal.ideal())
        }
        k
    }
}

pub trait FactorableIdealsSignature<Ring: DedekindDomainSignature>:
    DedekindDomainIdealsSignature<Ring>
{
    fn factor_ideal(
        &self,
        ideal: &Self::Set,
    ) -> Option<DedekindDomainIdealFactorization<Ring, Self>>;
    fn is_prime_ideal(&self, ideal: &Self::Set) -> bool {
        if let Some(f) = self.factor_ideal(ideal) {
            f.is_prime()
        } else {
            false
        }
    }
}

#[derive(Debug, Clone)]
pub struct DedekindDomainPrimeIdeal<
    Ring: DedekindDomainSignature,
    Ideals: DedekindDomainIdealsSignature<Ring>,
> {
    _ring: PhantomData<Ring>,
    prime_ideal: Ideals::Set,
}

impl<Ring: DedekindDomainSignature, Ideals: DedekindDomainIdealsSignature<Ring>>
    DedekindDomainPrimeIdeal<Ring, Ideals>
{
    pub fn from_ideal_unchecked(ideal: Ideals::Set) -> Self {
        Self {
            _ring: PhantomData::default(),
            prime_ideal: ideal,
        }
    }

    pub fn into_ideal(self) -> Ideals::Set {
        self.prime_ideal
    }

    pub fn ideal(&self) -> &Ideals::Set {
        &self.prime_ideal
    }
}

impl<Ring: DedekindDomainSignature, Ideals: DedekindDomainIdealsSignature<Ring>>
    FactoredSignature<DedekindDomainIdealFactorization<Ring, Ideals>> for Ideals
{
    type PrimeObject = DedekindDomainPrimeIdeal<Ring, Ideals>;

    type FactoredObject = Ideals::Set;

    fn object_divides(&self, a: &Self::FactoredObject, b: &Self::FactoredObject) -> bool {
        self.ideal_contains(a, b)
    }

    fn object_is_prime(&self, _object: &Self::PrimeObject) -> bool {
        true
    }

    fn prime_to_object(&self, prime: Self::PrimeObject) -> Self::FactoredObject {
        prime.into_ideal()
    }

    fn object_product(&self, objects: Vec<&Self::FactoredObject>) -> Self::FactoredObject {
        self.ideal_product(objects.into_iter().cloned().collect())
    }
}

#[derive(Debug, Clone)]
pub struct DedekindDomainIdealFactorization<
    Ring: DedekindDomainSignature,
    Ideals: DedekindDomainIdealsSignature<Ring>,
> {
    ideals: Ideals,
    // The prime ideals should be distinct
    // All powers should be non-zero
    factors: Vec<(DedekindDomainPrimeIdeal<Ring, Ideals>, Natural)>,
}

impl<Ring: DedekindDomainSignature, Ideals: DedekindDomainIdealsSignature<Ring>> Factored
    for DedekindDomainIdealFactorization<Ring, Ideals>
{
    type Structure = Ideals;

    fn factored_structure<'a>(&'a self) -> impl 'a + std::borrow::Borrow<Self::Structure> {
        &self.ideals
    }

    fn from_factor_powers_impl(
        structure: Self::Structure,
        factor_powers: Vec<(
            <Self::Structure as FactoredSignature<Self>>::PrimeObject,
            Natural,
        )>,
    ) -> Self {
        Self {
            ideals: structure,
            factors: factor_powers,
        }
    }

    fn factor_powers(
        &self,
    ) -> Vec<(
        &<Self::Structure as FactoredSignature<Self>>::PrimeObject,
        &Natural,
    )> {
        self.factors.iter().map(|(p, k)| (p, k)).collect()
    }

    fn into_factor_powers(
        self,
    ) -> Vec<(
        <Self::Structure as FactoredSignature<Self>>::PrimeObject,
        Natural,
    )> {
        self.factors
    }

    fn expanded(&self) -> <Self::Structure as FactoredSignature<Self>>::FactoredObject {
        self.ideals.ideal_product(
            self.factor_list()
                .into_iter()
                .map(|p| p.ideal().clone())
                .collect(),
        )
    }

    fn mul(mut a: Self, b: Self) -> Self {
        let ring = common_structure::<Ideals>(a.factored_structure(), b.factored_structure());
        for (q, l) in b.into_factor_powers() {
            'SEARCH_A: {
                for (p, k) in &mut a.factors {
                    if ring.object_equivalent(p.ideal(), q.ideal()) {
                        *k += l;
                        break 'SEARCH_A;
                    }
                }
                a.factors.push((q, l));
            }
        }
        a
    }
}

// #[derive(Debug, Clone)]
// pub struct DedekindDomainFractionalIdeal<RS: DedekindDomainIdealsSignature> {
//     ring: RS,
//     // The prime ideals should be distinct
//     // All powers should be non-zero
//     factors: Vec<(DedekindDomainPrimeIdeal<RS>, Integer)>,
// }
